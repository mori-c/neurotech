// This program detects EMG muscle contractions with the following algorithm
//
//   1) Apply threshold
//   2) Monitor thresholded signal for a rising edge, which indicates a muscle contraction
//   3) Hold this reading until we receive a request over Serial to send the reading. Once the reading is sent,
//      reset and continue monitoring for the next rising edge or contraction.
//
//    This program reads one sample from pin A5 (which will connect to the circuit output and sends it to a computer with Serial.println().
//    If you don't have the EMG circuit, any analog sensor can serve as a replacement.
//

///////////////////// Effects ///////////////////////////////
#include <Tone_Gen.h>

boolean skip_calibration = true;

////////////////////// Options //////////////////////////////

// Set to true if you want to generate your own input wave.
// Set to false if you want to read data from your analog input.
boolean use_emulator = true;

///////////////////// Effects ///////////////////////////////


// Set to true to introduce some noise into the emulator
boolean inject_noise = false;

// Moving average filter
boolean low_pass = true;

//////// Configurable parameters //////////

// Frequency of the sine wave generated by the emulator
double emulator_frequency = 5;

// Noise is usually random, but here I just use a frequency much higher than the emulator frequency.
double noise_frequency = 333;

// Make sure the sample rate is greater than twice the emulator frequency.
// If equal or lower, you will get aliasing, and the output will not be
// what you want.
// 2400 SPS was the best case sampling rate achievable with no buffering
int sample_rate = 1000;

// SNR = Signal to Noise Ratio ~ The ratio in amplitudes between a signal of interest and noise
double snr = 2;

/////////// Constants /////////////////////

const int PRINT_PERCISION = 8;
const int BITS_PER_SAMPLE = 10;

// Peak to peak voltage of incoming signal
const double VPP = 5;
double threshold = VPP / 2;
int ana_port = A5;

char REQUEST_SYMBOL = '?';
///////////////////////////////////////////

Tone_Gen *signal_emulator;
Tone_Gen *noise_emulator;
int resolution;
double sample;

// Low pass filter
const int N_TAPS = 30;
double moving_average[N_TAPS];
int avg_index = 0;

// Variables for muscle contraction detection
boolean thresholded_sample, prev_sample;
char request;
boolean decision;

// Function prototype for calibrate_signal_level() function defined below. Needed so we can set
// default parameters
double calibrate_signal_level(char start_symbol = ' ', char done_symbol = ' ');

void setup() {

  // Make sure what ever you put here matches your Serial Monitor setting
  Serial.begin(9600);
  Serial.flush();
  pinMode(ana_port, INPUT);

  resolution = pow(2, BITS_PER_SAMPLE);

  // Initialize variables
  decision = false;
  thresholded_sample = 0;
  prev_sample = 0;
  double relaxed_level = 0;
  double curled_level = VPP;

  // Calibrate

  if (!skip_calibration) {
    relaxed_level = calibrate_signal_level();
    delay(1000);
    curled_level = calibrate_signal_level();
  }

  threshold = (curled_level - relaxed_level) / 2;


  // EMG signal generator
  // Use sampling rate of 1000 SPS
  signal_emulator = new Tone_Gen(1000);
  
  // Noise generator
  noise_emulator = new Tone_Gen(1000);
  
  // Needed for actual random data
  randomSeed(analogRead(0));

} // end setup()

void loop() {

  // Use the emulator for testing if we don't have a real analog input available
  if (use_emulator) {
    sample = get_next_emulator_sample();
  }
  else {
    // Sample the analog input into pin A5 and convert it to a real value
    sample = analogRead(ana_port);
    sample *= VPP / resolution;
  }

  // Filter noise
  if (low_pass) low_pass_signal(sample);
  
   // Add noise, for testing purposes. Do not add noise when running the real system
  if (inject_noise) add_noise(sample, noise_frequency);

  // Change the 10 bit to 1-bit sample by comparing the sample against a threshold
  thresholded_sample = (sample > threshold); // If sample > threshold, this statement is 1, otherwise, it is 0;

  // Check if a rising edge happened. If it did, make decision 1 
  if (thresholded_sample > prev_sample) {
    decision = true;
  }

  // Call our wrapper function send_over_serial() with blocking set to false since we do not want to wait for a request.
  boolean sample_sent = send_over_serial(decision, false);

  if (sample_sent) {
    // Make decision false after the game has been notified of the rising edge. 
    // Note that this is the only place in our loop that we set decision to 0. This
    // ensures that a muscle contraction is never missed. 
    decision = false;
  } 

  // Keep track of the current sample for comparison with the next sample
  prev_sample = thresholded_sample;
  delay(5);


} // end loop()

/////////// Functions ///////////////////


// This function returns the average signal level for a specific situation by allowing the user to go through a calibration
// sequence
// 
// Intended Use:
//   Prepare the input analog signal to what you'd like to calibrate (e.g. curled bicep, clenched fist, relaxed arm, etc.)
//   The calibration itself works by continuously sampling the input signal for 3 seconds, then averaging the samples to determine
//   the approximate input signal level that can be used to identify the situation.
//
//   If start_symbol is passed in, the calibration will only start when the program receives the start_symbol over Serial. Otherwise,
//   calibration will start as soon as the function is called.
//   Similarily, if done_symbol is passed in, the program will send a done symbol once calibration finishes. Otherwise, it will procede
//   without notifying the PC.
//
double calibrate_signal_level(char start_symbol, char done_symbol) {
  double sample = 0, sum = 0, calibration_result = 0;
  int num_samples = 0;

  // Check if start_symbol is something other than the default
  if (start_symbol != ' ') {
    // Wait to receive the start_symbol over Serial
    while (!check_buffer_for_symbol(start_symbol));
  }

  // Record the current time
  double start_cal_time = millis();

  // Set the calibration timeout to 3000 ms (3 milliseconds)
  double timeout = 3000;

  while ((millis() - start_cal_time) < timeout) {
    // Sample and convert the sample to a voltage
    sample = analogRead(ana_port) * VPP/resolution;

    sum += sample;
    num_samples++;
  }

  // Average the samples
  calibration_result = sum / num_samples;

  // Check if done_symbol is something other than the default
  if (done_symbol != ' ') {
    // Call our serial wrapper function send_over_serial() with blocking set to true because
    // we want to make sure the PC is ready to receive data before sending.
    send_over_serial(done_symbol, true);
  }

  return calibration_result;
}

// Wrapper function for Serial.println(). Since our receiving program is asynchronous to its transmitter (this program)
// we need to use requests to ensure we only send data when the receiver is ready to receive. To do this, we
// look out for "requests" from the receiver before sending our data.
//
// If blocking is false, only check if request is received
// If blocking is true, wait until a request is received.
boolean send_over_serial(byte byte_msg, boolean blocking) {
  boolean req_received;

  do {
    // Check if we've received a request
    req_received = check_buffer_for_symbol(REQUEST_SYMBOL);
  } 
  while (blocking && !req_received); // Only continue to check if blocking is true;

  if (req_received) Serial.println(byte_msg);

  return req_received;
}

// Wrapper function for Serial.println(). Since our receiving program is asynchronous to its transmitter (this program)
// we need to use requests to ensure we only send data when the receiver is ready to receive. To do this, we
// look out for "requests" from the receiver before sending our data.
//
// If blocking is false, only check if request is received
// If blocking is true, wait until a request is received.
boolean send_over_serial(double double_msg, boolean blocking) {
  boolean req_received;

  do {
    // Check if we've received a request
    req_received = check_buffer_for_symbol(REQUEST_SYMBOL);
  } 
  while (blocking && !req_received); // Only continue to check if blocking is true;

  if (req_received) Serial.println(double_msg);

  return req_received;
}

// Wrapper function for Serial.println(). Since our receiving program is asynchronous to its transmitter (this program)
// we need to use requests to ensure we only send data when the receiver is ready to receive. To do this, we
// look out for "requests" from the receiver before sending our data.
//
// If blocking is false, only check if request is received
// If blocking is true, wait until a request is received.
boolean send_over_serial(char char_msg, boolean blocking) {
  boolean valid_to_send;

  do {
    valid_to_send = check_buffer_for_symbol(REQUEST_SYMBOL);
  } 
  while (blocking && !valid_to_send); // Only keep checking if blocking is true;

  if (valid_to_send) Serial.println(char_msg);

  return valid_to_send;
}

// Return true or false, indicating whether the receiver is ready to receive serial data or not. This is done by checking the Serial RX buffer
// for a "target_symbol"
boolean check_buffer_for_symbol(char target_symbol) {
  char receive_byte;

  if (Serial.available() > 0) {
    receive_byte = Serial.read();

    if (receive_byte == target_symbol) 
      return true;
    else 
      return false;
  }
}

/////////// Functions ///////////////////

double get_next_emulator_sample() {
  double sample;
  // Get the next sample of a <emulator_frequency> Hz sine wave with a peak-peak amplitude of VPP
  sample = signal_emulator->nextSample(emulator_frequency, VPP / 2);

  // Add a DC offset of half the peak to peak voltage to shift output between 0V and 5V
  sample += VPP / 2;
  return sample;
}

void add_noise(double & sample, double noise_frequency) {
  double freq = random(noise_frequency * 0.8, noise_frequency * 1.2);
  double amp = random(0, VPP);
  sample += noise_emulator->nextSample(freq, (amp / 2) / snr);
}

void low_pass_signal(double & sample) {
  double new_sample = sample;
  double sum = 0;
  
  if (avg_index < N_TAPS) {
    moving_average[avg_index] = sample;
    avg_index++;
  }
  else {
    for (int m = N_TAPS - 1; m >= 0; m--) {
      if (m == 0)
        moving_average[m] = new_sample;
      else
        moving_average[m] = moving_average[m - 1];

      sum += moving_average[m];
    }
  }
  sample = sum / N_TAPS;
}
















