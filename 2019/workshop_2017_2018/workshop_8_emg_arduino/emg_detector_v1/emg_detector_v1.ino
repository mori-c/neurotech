// This program detects EMG muscle contractions with the following algorithm
//
//   1) Apply threshold
//   2) Monitor thresholded signal for a rising edge, which indicates a muscle contraction
//   3) Hold this reading until we receive a request over Serial to send the reading. Once the reading is sent,
//      reset and continue monitoring for the next rising edge or contraction.
//
// This program has two modes:
// 1. use_emulator = false
//    This mode will be used when we want to actually read an analog input (EMG signal, etc). It reads one sample from
//    pin A5 (which will connect to the circuit output and sends it to a computer with Serial.println().
//    If you don't have the EMG circuit, any analog sensor can serve as a replacement.
//
// 2. use_emulator = true;
//    In this mode, instead of taking samples from an input pin, samples are taken from a Tone_Gen object that
//    basically spouts out samples of a sine wave. This wave is ideal and won't be representative of the
//    the actual input the Arduino will receive, but is a good way to test the pipeline independently of the
//    the EMG circuit. In this file, I include the option to simulate "noise" in a signal by setting inject_noise
//    to true and changing the noise_frequency and snr parameters.
//

#include <Tone_Gen.h>

////////////////////// Options //////////////////////////////

// Set to true if you want to generate your own input wave.
// Set to false if you want to read data from your analog input.
boolean use_emulator = true;

///////////////////// Effects ///////////////////////////////


// Set to true to introduce some noise into the emulator
boolean inject_noise = false;

// Moving average filter
boolean low_pass = true;

//////// Configurable parameters //////////

// Frequency of the sine wave generated by the emulator
double emulator_frequency = 5;

// Noise is usually random, but here I just use a frequency much higher than the emulator frequency.
double noise_frequency = 333;

// Make sure the sample rate is greater than twice the emulator frequency.
// If equal or lower, you will get aliasing, and the output will not be
// what you want.
// 2400 SPS was the best case sampling rate achievable with no buffering
int sample_rate = 1000;

// SNR = Signal to Noise Ratio ~ The ratio in amplitudes between a signal of interest and noise
double snr = 2;

/////////// Constants /////////////////////
const int PRINT_PERCISION = 8;
const int BITS_PER_SAMPLE = 10;

// Peak to peak voltage of incoming signal
const double VPP = 5;
double threshold = VPP / 2;
int ana_port = A5;

///////////////////////////////////////////

Tone_Gen *signal_emulator;
Tone_Gen *noise_emulator;
int resolution;
double sample;

// Low pass filter
const int N_TAPS = 30;
double moving_average[N_TAPS];
int avg_index = 0;

// Variables for muscle contraction detection
boolean thresholded_sample, prev_sample;
char request;
boolean decision;

void setup() {

  // Make sure what ever you put here matches your Serial Monitor setting
  Serial.begin(115200);
  Serial.flush();
  pinMode(ana_port, INPUT);

  resolution = pow(2, BITS_PER_SAMPLE);

  // Initialize variables
  decision = false;
  thresholded_sample = 0;
  prev_sample = 0;

  // EMG signal generator
  // Use sampling rate of 1000 SPS
  signal_emulator = new Tone_Gen(1000);
  
  // Noise generator
  noise_emulator = new Tone_Gen(1000);
  
  // Needed for actual random data
  randomSeed(analogRead(0));
} // end setup()

void loop() {


  // Use the emulator for testing if we don't have a real analog input available
  if (use_emulator) {
    sample = get_next_emulator_sample();
  }
  else {
    // Sample the analog input into pin A5 and convert it to a real value
    sample = analogRead(ana_port);
    sample *= VPP / resolution;
  }

  // Filter noise
  if (low_pass) low_pass_signal(sample);
  
  // Add noise, for testing purposes. Do not add noise when running the real system
  if (inject_noise) add_noise(sample, noise_frequency);

  // Change the 10 bit to 1-bit sample by comparing the sample against a threshold
  thresholded_sample = (sample > threshold); // If sample > threshold, this statement is 1, otherwise, it is 0;

  // Check if a rising edge happened. If it did, make decision 1 
  if (thresholded_sample > prev_sample) {
    decision = true;
  }

  // Check if there is something in our receive buffer to read
  if (Serial.available() > 0) {

    // Read from our receive buffer
    request = Serial.read();

    // We've chose the '?' character to be our request
    if (request == '?') {

      // Send the decision
      Serial.println(decision);

      // Make decision equal to 0 after the game has been notified of the rising edge. 
      // Note that this is the only place in our loop that we set decision to 0. This
      // ensures that a muscle contraction is never missed. 
      decision = false;
    }
  }

  // Keep track of the current sample for comparison with the next sample
  prev_sample = thresholded_sample;
  delay(5);

} // end loop()

/////////// Functions ///////////////////

double get_next_emulator_sample() {
  double sample;
  // Get the next sample of a <emulator_frequency> Hz sine wave with a peak-peak amplitude of VPP
  sample = signal_emulator->nextSample(emulator_frequency, VPP / 2);

  // Add a DC offset of half the peak to peak voltage to shift output between 0V and 5V
  sample += VPP / 2;
  return sample;
}

void add_noise(double & sample, double noise_frequency) {
  double freq = random(noise_frequency * 0.8, noise_frequency * 1.2);
  double amp = random(0, VPP);
  sample += noise_emulator->nextSample(freq, (amp / 2) / snr);
}

void low_pass_signal(double & sample) {
  double new_sample = sample;
  double sum = 0;
  if (avg_index < N_TAPS) {
    moving_average[avg_index] = sample;
    avg_index++;
  }
  else {
    for (int m = N_TAPS - 1; m >= 0; m--) {
      if (m == 0)
        moving_average[m] = new_sample;
      else
        moving_average[m] = moving_average[m - 1];

      sum += moving_average[m];
    }
  }
  sample = sum / N_TAPS;
}












