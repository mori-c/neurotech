// This program detects EMG muscle contractions with the following algorithm
// 
//   1) Apply threshold
//   2) Monitor thresholded signal for a rising edge, which indicates a muscle contraction
//   3) Hold this reading until we receive a request over Serial to send the reading. Once the reading is sent,
//      reset and continue monitoring for the next rising edge or contraction.
//
// This program has two modes:
// 1. use_emulator = false
//    This mode will be used when we want to actually read an analog input (EMG signal, etc). It reads one sample from 
//    pin A5 (which will connect to the circuit output and sends it to a computer with Serial.println().
//    If you don't have the EMG circuit, any analog sensor can serve as a replacement.
//
// 2. use_emulator = true;
//    In this mode, instead of taking samples from an input pin, samples are taken from a Tone_Gen object that
//    basically spouts out samples of a sine wave. This wave is ideal and won't be representative of the
//    the actual input the Arduino will receive, but is a good way to test the pipeline independently of the 
//    the EMG circuit. In this file, I include the option to simulate "noise" in a signal by setting inject_noise
//    to true and changing the noise_frequency and snr parameters.
//     

// Move the Tone_Gen folder in this directory to the libraries folder where arduino is installed
#include <Tone_Gen.h>

////////////////////// Options //////////////////////////////

// Set to true if you want to generate your own input wave.
// Set to false if you want to read data from your analog input.
boolean use_emulator = true;

///////////////////// Effects ///////////////////////////////


// Set to true to introduce some noise into the emulator
boolean inject_noise = false;

// Moving average filter
boolean low_pass = false;

//////// Configurable parameters //////////

// Frequency of the sine wave generated by the emulator
double emulator_frequency = 40; 

// Noise is usually random, but here I just use a frequency much higher than the emulator frequency.
double noise_frequency = 333;

// Make sure the sample rate is greater than twice the emulator frequency.
// If equal or lower, you will get aliasing, and the output will not be 
// what you want.
// 2400 SPS was the best case sampling rate achievable with no buffering
int sample_rate = 1800; 

// SNR = Signal to Noise Ratio ~ The ratio in amplitudes between a signal of interest and noise
double snr = 2;

/////////// Constants /////////////////////
const int PRINT_PERCISION = 8;
const int BITS_PER_SAMPLE = 10;

// Peak to peak voltage of incoming signal
const double VPP = 5; 
double threshold = VPP/2;
int ana_port = A5;

///////////////////////////////////////////

Tone_Gen *signal_emulator;
Tone_Gen *noise_emulator;
int resolution;
double sample;

// Low pass filter
const int N_TAPS = 30;
double moving_average[N_TAPS];
int avg_index;

const double MICROSEC_TO_SEC = 1000000;

// Variables for muscle contraction detection
boolean curr_sample, prev_sample;
char incoming_byte;
boolean decision;

void setup() {

  // Make sure what ever you put here matches your Serial Monitor setting
  Serial.begin(115200);
  Serial.flush();
  pinMode(ana_port, INPUT);

  resolution = pow(2, BITS_PER_SAMPLE);

  // EMG signal
  signal_emulator = new Tone_Gen(sample_rate);

  // Noise
  noise_emulator = new Tone_Gen(sample_rate);
  randomSeed(analogRead(0));

  // Initialize variables
  decision = false;
  curr_sample = 0;
  prev_sample = 0;
} // end setup()

void loop() {

  // Use the emulator for testing if we don't have a real analog input available
  if (use_emulator) {
    sample = get_next_emulator_sample();
  } 
  else {
    // Sample the analog input into pin A5 and convert it to a real value
    sample = analogRead(ana_port); 
    sample *= VPP / resolution;
  }

  // Inject noise into the analog sensor reading. Randomize the amplitude and frequency
  if (inject_noise) add_noise(sample, noise_frequency);

  // Filter noise
  if (low_pass) low_pass_signal(sample);

  // Change the 10 bit to 1-bit sample by comparing the sample against a threshold
  curr_sample = (sample > threshold); // If sample > threshold, this statement is 1, otherwise, it is 0;

  // Check if rising edge happened. If it did, make decision 1 to keep tracking
  if (curr_sample > prev_sample) {
    decision = true;
  }

  // Check if the game has requested a sample
  if (Serial.available() > 0) {
    incoming_byte = Serial.read();
    if (incoming_byte == '?') {
      Serial.println(decision);

      // Only reset decision to 0 after the game has been notified of the rising edge
      decision = false;
    } 
  }  

  // Keep track of the current sample for comparison with the next sample
  prev_sample = curr_sample;

  delay(5);
} // end loop()

/////////// Functions ///////////////////

double get_next_emulator_sample() {
  double sample;
  // Get the next sample of a <emulator_frequency> Hz sine wave with a peak-peak amplitude of VPP
  sample = signal_emulator->nextSample(emulator_frequency, VPP/2);

  // Add a DC offset of half the peak to peak voltage to shift output between 0V and 5V
  sample += VPP / 2;
  return sample;
}

void add_noise(double &sample, double noise_frequency) {
  double freq = random(noise_frequency*0.8, noise_frequency*1.2);
  double amp = random(0,VPP);
  sample += noise_emulator->nextSample(freq, (amp/2)/snr);  
}

void low_pass_signal(double &sample) {
  double new_sample = sample;
  double sum = 0;
  if (avg_index < N_TAPS) {
    moving_average[avg_index] = sample;
    avg_index++;
  } 
  else {
    for (int m = N_TAPS - 1; m >= 0; m--) {
      if (m == 0)
        moving_average[m] = new_sample;
      else
        moving_average[m] = moving_average[m-1];

      sum += moving_average[m];
    }
  }
  sample = sum / N_TAPS;
}











